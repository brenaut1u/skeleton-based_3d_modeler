#include "vec3.h"

vec3& vec3::operator+=(const vec3 &v) {
    e[0] += v.e[0];
    e[1] += v.e[1];
    e[2] += v.e[2];
    return *this;
}

vec3& vec3::operator*=(double t) {
    e[0] *= t;
    e[1] *= t;
    e[2] *= t;
    return *this;
}

bool vec3::operator==(const vec3 &v) const {
    if (e[0] != v.e[0]) {
        return false;
    }
    if (e[1] != v.e[1]) {
        return false;
    }
    if (e[2] != v.e[2]) {
        return false;
    }
    return true;
}

bool vec3::near_zero() const {
    // Return true if the vector is close to zero in all dimensions.
    auto s = 1e-8;
    return (fabs(e[0]) < s) && (fabs(e[1]) < s) && (fabs(e[2]) < s);
}

vec3 random_in_unit_sphere() {
    while (true) {
        auto p = vec3::random(-1,1);
        if (p.length_squared() < 1)
            return p;
    }
}

vec3 random_on_hemisphere(const vec3& normal) {
    vec3 on_unit_sphere = random_unit_vector();
    if (dot(on_unit_sphere, normal) > 0.0) // In the same hemisphere as the normal
        return on_unit_sphere;
    else
        return -on_unit_sphere;
}

point3 point_rotation(point3 p, point3 axis_point, vec3 axis, double angle) {
    vec3 v = p - axis_point;
    double len = v.length();
    vec3 v_rot = unit_vector(vector_rotation(v, axis, angle))*len;
    return axis_point + v_rot;
}

vec3 round_vector(const vec3& v) {
    return { round(v.x()), round(v.y()), round(v.z()) };
}